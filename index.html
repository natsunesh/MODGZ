<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="shaderCanvas"></canvas>
    <script type="text/javascript">
        const canvas = document.getElementById('shaderCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            void main() {
                v_texCoord = a_position;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D iChunk;
            uniform vec2 iChunkSize;
            uniform float iTick;
            varying vec2 v_texCoord;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = v_texCoord / iChunkSize;
                float noise = random(uv * iTick * 0.05);
                float scanLine = sin(uv.y * 800.0 + iTick * 0.1) * 0.1;
                float r = random(uv + vec2(iTick * 0.02, 0.0));
                float g = random(uv + vec2(iTick * 0.03, 0.0));
                vec2 center = vec2(0.5, 0.5);
                float dist = length(uv - center);
                float glow = 0.02 / dist * sin(iTick * 0.03);
                vec4 original = texture2D(iChunk, uv);
                vec4 effect = vec4(r * 0.8, g * 0.3, glow * 0.5, 1.0);
                gl_FragColor = mix(original, effect, 0.3);
            }
        `;

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const iChunkLocation = gl.getUniformLocation(program, 'iChunk');
        const iChunkSizeLocation = gl.getUniformLocation(program, 'iChunkSize');
        const iTickLocation = gl.getUniformLocation(program, 'iTick');

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const image = new Image();
image.src = 'shader/alastor_radio.txt';
        image.onload = () => {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.generateMipmap(gl.TEXTURE_2D);
        };

        function render(time) {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.uniform1i(iChunkLocation, 0);
            gl.uniform2f(iChunkSizeLocation, canvas.width, canvas.height);
            gl.uniform1f(iTickLocation, time * 0.001);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html> -->
